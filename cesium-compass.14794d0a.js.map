{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,U,I,G,I,E,E,S,E,E,S,E,E,S,E,E,SCiBA,SAAS,EAAW,CAAC,CAAE,CAAC,EAMtB,IAAI,CAAC,CAAC,CAAG,GAAK,EAOd,IAAI,CAAC,CAAC,CAAG,GAAK,CAChB,CAUA,EAAW,YAAY,CAAG,SAAU,CAAC,CAAE,CAAC,CAAE,CAAM,QAC9C,AAAK,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,IAIb,EAAO,CAAC,CAAG,EACX,EAAO,CAAC,CAAG,EACJ,GALE,IAAI,EAAW,EAAG,EAM7B,EASA,EAAW,KAAK,CAAG,SAAU,CAAS,CAAE,CAAM,EAC5C,GAAK,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,SAGb,AAAK,AAAA,CAAA,EAAA,EAAA,OAAM,AAAN,EAAQ,IAIb,EAAO,CAAC,CAAG,EAAU,CAAC,CACtB,EAAO,CAAC,CAAG,EAAU,CAAC,CACf,GALE,IAAI,EAAW,EAAU,CAAC,CAAE,EAAU,CAAC,CAMlD,EAWA,EAAW,cAAc,CAAG,EAAW,KAAK,CAW5C,EAAW,cAAc,CAAG,EAAW,KAAK,CAM5C,EAAW,YAAY,CAAG,EAW1B,EAAW,IAAI,CAAG,SAAU,CAAK,CAAE,CAAK,CAAE,CAAa,EAWrD,OATA,AAAA,EAAA,OAAI,CAAE,MAAM,CAAC,MAAM,CAAC,QAAS,GAC7B,AAAA,EAAA,OAAI,CAAE,OAAO,CAAC,QAAS,GAGvB,EAAgB,GAAiB,EAEjC,CAAK,CAAC,IAAgB,CAAG,EAAM,CAAC,CAChC,CAAK,CAAC,EAAc,CAAG,EAAM,CAAC,CAEvB,CACT,EAUA,EAAW,MAAM,CAAG,SA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","sources":["<anon>","node_modules/@cesium/engine/Source/Core/Cartesian2.js","node_modules/@cesium/engine/Source/Core/Cartesian3.js","node_modules/@cesium/engine/Source/Core/Ray.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5532\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5532\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kWQjc\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f401ccd6337211aa$export$2e2bcd8739ae039);\n\nvar $3pzcG = parcelRequire(\"3pzcG\");\n\nvar $jQJji = parcelRequire(\"jQJji\");\n\nvar $1vHsR = parcelRequire(\"1vHsR\");\n\nvar $AXvpI = parcelRequire(\"AXvpI\");\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */ function $f401ccd6337211aa$var$Cartesian2(x, y) {\n    /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */ this.x = x ?? 0.0;\n    /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */ this.y = y ?? 0.0;\n}\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */ $f401ccd6337211aa$var$Cartesian2.fromElements = function(x, y, result) {\n    if (!(0, $jQJji.default)(result)) return new $f401ccd6337211aa$var$Cartesian2(x, y);\n    result.x = x;\n    result.y = y;\n    return result;\n};\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */ $f401ccd6337211aa$var$Cartesian2.clone = function(cartesian, result) {\n    if (!(0, $jQJji.default)(cartesian)) return undefined;\n    if (!(0, $jQJji.default)(result)) return new $f401ccd6337211aa$var$Cartesian2(cartesian.x, cartesian.y);\n    result.x = cartesian.x;\n    result.y = cartesian.y;\n    return result;\n};\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */ $f401ccd6337211aa$var$Cartesian2.fromCartesian3 = $f401ccd6337211aa$var$Cartesian2.clone;\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */ $f401ccd6337211aa$var$Cartesian2.fromCartesian4 = $f401ccd6337211aa$var$Cartesian2.clone;\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */ $f401ccd6337211aa$var$Cartesian2.packedLength = 2;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */ $f401ccd6337211aa$var$Cartesian2.pack = function(value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"value\", value);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    startingIndex = startingIndex ?? 0;\n    array[startingIndex++] = value.x;\n    array[startingIndex] = value.y;\n    return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */ $f401ccd6337211aa$var$Cartesian2.unpack = function(array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    startingIndex = startingIndex ?? 0;\n    if (!(0, $jQJji.default)(result)) result = new $f401ccd6337211aa$var$Cartesian2();\n    result.x = array[startingIndex++];\n    result.y = array[startingIndex];\n    return result;\n};\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {number[]} The packed array.\n */ $f401ccd6337211aa$var$Cartesian2.packArray = function(array, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    const length = array.length;\n    const resultLength = length * 2;\n    if (!(0, $jQJji.default)(result)) result = new Array(resultLength);\n    else if (!Array.isArray(result) && result.length !== resultLength) //>>includeStart('debug', pragmas.debug);\n    throw new (0, $1vHsR.default)(\"If result is a typed array, it must have exactly array.length * 2 elements\");\n    else if (result.length !== resultLength) result.length = resultLength;\n    for(let i = 0; i < length; ++i)$f401ccd6337211aa$var$Cartesian2.pack(array[i], result, i * 2);\n    return result;\n};\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */ $f401ccd6337211aa$var$Cartesian2.unpackArray = function(array, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    (0, $3pzcG.default).typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n    if (array.length % 2 !== 0) throw new (0, $1vHsR.default)(\"array length must be a multiple of 2.\");\n    //>>includeEnd('debug');\n    const length = array.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 2);\n    else result.length = length / 2;\n    for(let i = 0; i < length; i += 2){\n        const index = i / 2;\n        result[index] = $f401ccd6337211aa$var$Cartesian2.unpack(array, i, result[index]);\n    }\n    return result;\n};\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */ $f401ccd6337211aa$var$Cartesian2.fromArray = $f401ccd6337211aa$var$Cartesian2.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */ $f401ccd6337211aa$var$Cartesian2.maximumComponent = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return Math.max(cartesian.x, cartesian.y);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */ $f401ccd6337211aa$var$Cartesian2.minimumComponent = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return Math.min(cartesian.x, cartesian.y);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */ $f401ccd6337211aa$var$Cartesian2.minimumByComponent = function(first, second, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"first\", first);\n    (0, $3pzcG.default).typeOf.object(\"second\", second);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.min(first.x, second.x);\n    result.y = Math.min(first.y, second.y);\n    return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */ $f401ccd6337211aa$var$Cartesian2.maximumByComponent = function(first, second, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"first\", first);\n    (0, $3pzcG.default).typeOf.object(\"second\", second);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.max(first.x, second.x);\n    result.y = Math.max(first.y, second.y);\n    return result;\n};\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */ $f401ccd6337211aa$var$Cartesian2.clamp = function(value, min, max, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"value\", value);\n    (0, $3pzcG.default).typeOf.object(\"min\", min);\n    (0, $3pzcG.default).typeOf.object(\"max\", max);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const x = (0, $AXvpI.default).clamp(value.x, min.x, max.x);\n    const y = (0, $AXvpI.default).clamp(value.y, min.y, max.y);\n    result.x = x;\n    result.y = y;\n    return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */ $f401ccd6337211aa$var$Cartesian2.magnitudeSquared = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */ $f401ccd6337211aa$var$Cartesian2.magnitude = function(cartesian) {\n    return Math.sqrt($f401ccd6337211aa$var$Cartesian2.magnitudeSquared(cartesian));\n};\nconst $f401ccd6337211aa$var$distanceScratch = new $f401ccd6337211aa$var$Cartesian2();\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */ $f401ccd6337211aa$var$Cartesian2.distance = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $f401ccd6337211aa$var$Cartesian2.subtract(left, right, $f401ccd6337211aa$var$distanceScratch);\n    return $f401ccd6337211aa$var$Cartesian2.magnitude($f401ccd6337211aa$var$distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */ $f401ccd6337211aa$var$Cartesian2.distanceSquared = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $f401ccd6337211aa$var$Cartesian2.subtract(left, right, $f401ccd6337211aa$var$distanceScratch);\n    return $f401ccd6337211aa$var$Cartesian2.magnitudeSquared($f401ccd6337211aa$var$distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.normalize = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const magnitude = $f401ccd6337211aa$var$Cartesian2.magnitude(cartesian);\n    result.x = cartesian.x / magnitude;\n    result.y = cartesian.y / magnitude;\n    //>>includeStart('debug', pragmas.debug);\n    if (isNaN(result.x) || isNaN(result.y)) throw new (0, $1vHsR.default)(\"normalized result is not a number\");\n    //>>includeEnd('debug');\n    return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The dot product.\n */ $f401ccd6337211aa$var$Cartesian2.dot = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    return left.x * right.x + left.y * right.y;\n};\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The cross product.\n */ $f401ccd6337211aa$var$Cartesian2.cross = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    return left.x * right.y - left.y * right.x;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.multiplyComponents = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x * right.x;\n    result.y = left.y * right.y;\n    return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.divideComponents = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x / right.x;\n    result.y = left.y / right.y;\n    return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.add = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x + right.x;\n    result.y = left.y + right.y;\n    return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.subtract = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x - right.x;\n    result.y = left.y - right.y;\n    return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.number(\"scalar\", scalar);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = cartesian.x * scalar;\n    result.y = cartesian.y * scalar;\n    return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.divideByScalar = function(cartesian, scalar, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.number(\"scalar\", scalar);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = cartesian.x / scalar;\n    result.y = cartesian.y / scalar;\n    return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.negate = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = -cartesian.x;\n    result.y = -cartesian.y;\n    return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.abs = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.abs(cartesian.x);\n    result.y = Math.abs(cartesian.y);\n    return result;\n};\nconst $f401ccd6337211aa$var$lerpScratch = new $f401ccd6337211aa$var$Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */ $f401ccd6337211aa$var$Cartesian2.lerp = function(start, end, t, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"start\", start);\n    (0, $3pzcG.default).typeOf.object(\"end\", end);\n    (0, $3pzcG.default).typeOf.number(\"t\", t);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    $f401ccd6337211aa$var$Cartesian2.multiplyByScalar(end, t, $f401ccd6337211aa$var$lerpScratch);\n    result = $f401ccd6337211aa$var$Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n    return $f401ccd6337211aa$var$Cartesian2.add($f401ccd6337211aa$var$lerpScratch, result, result);\n};\nconst $f401ccd6337211aa$var$angleBetweenScratch = new $f401ccd6337211aa$var$Cartesian2();\nconst $f401ccd6337211aa$var$angleBetweenScratch2 = new $f401ccd6337211aa$var$Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */ $f401ccd6337211aa$var$Cartesian2.angleBetween = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $f401ccd6337211aa$var$Cartesian2.normalize(left, $f401ccd6337211aa$var$angleBetweenScratch);\n    $f401ccd6337211aa$var$Cartesian2.normalize(right, $f401ccd6337211aa$var$angleBetweenScratch2);\n    return (0, $AXvpI.default).acosClamped($f401ccd6337211aa$var$Cartesian2.dot($f401ccd6337211aa$var$angleBetweenScratch, $f401ccd6337211aa$var$angleBetweenScratch2));\n};\nconst $f401ccd6337211aa$var$mostOrthogonalAxisScratch = new $f401ccd6337211aa$var$Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */ $f401ccd6337211aa$var$Cartesian2.mostOrthogonalAxis = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const f = $f401ccd6337211aa$var$Cartesian2.normalize(cartesian, $f401ccd6337211aa$var$mostOrthogonalAxisScratch);\n    $f401ccd6337211aa$var$Cartesian2.abs(f, f);\n    if (f.x <= f.y) result = $f401ccd6337211aa$var$Cartesian2.clone($f401ccd6337211aa$var$Cartesian2.UNIT_X, result);\n    else result = $f401ccd6337211aa$var$Cartesian2.clone($f401ccd6337211aa$var$Cartesian2.UNIT_Y, result);\n    return result;\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */ $f401ccd6337211aa$var$Cartesian2.equals = function(left, right) {\n    return left === right || (0, $jQJji.default)(left) && (0, $jQJji.default)(right) && left.x === right.x && left.y === right.y;\n};\n/**\n * @private\n */ $f401ccd6337211aa$var$Cartesian2.equalsArray = function(cartesian, array, offset) {\n    return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */ $f401ccd6337211aa$var$Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n    return left === right || (0, $jQJji.default)(left) && (0, $jQJji.default)(right) && (0, $AXvpI.default).equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && (0, $AXvpI.default).equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */ $f401ccd6337211aa$var$Cartesian2.ZERO = Object.freeze(new $f401ccd6337211aa$var$Cartesian2(0.0, 0.0));\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */ $f401ccd6337211aa$var$Cartesian2.ONE = Object.freeze(new $f401ccd6337211aa$var$Cartesian2(1.0, 1.0));\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */ $f401ccd6337211aa$var$Cartesian2.UNIT_X = Object.freeze(new $f401ccd6337211aa$var$Cartesian2(1.0, 0.0));\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */ $f401ccd6337211aa$var$Cartesian2.UNIT_Y = Object.freeze(new $f401ccd6337211aa$var$Cartesian2(0.0, 1.0));\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */ $f401ccd6337211aa$var$Cartesian2.prototype.clone = function(result) {\n    return $f401ccd6337211aa$var$Cartesian2.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */ $f401ccd6337211aa$var$Cartesian2.prototype.equals = function(right) {\n    return $f401ccd6337211aa$var$Cartesian2.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */ $f401ccd6337211aa$var$Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\n    return $f401ccd6337211aa$var$Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.\n */ $f401ccd6337211aa$var$Cartesian2.prototype.toString = function() {\n    return `(${this.x}, ${this.y})`;\n};\nvar $f401ccd6337211aa$export$2e2bcd8739ae039 = $f401ccd6337211aa$var$Cartesian2;\n\n});\n\nparcelRegister(\"bXwZF\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $8b4ecc405ab6d560$export$2e2bcd8739ae039);\n\nvar $3pzcG = parcelRequire(\"3pzcG\");\n\nvar $jQJji = parcelRequire(\"jQJji\");\n\nvar $1vHsR = parcelRequire(\"1vHsR\");\n\nvar $AXvpI = parcelRequire(\"AXvpI\");\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */ function $8b4ecc405ab6d560$var$Cartesian3(x, y, z) {\n    /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */ this.x = x ?? 0.0;\n    /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */ this.y = y ?? 0.0;\n    /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */ this.z = z ?? 0.0;\n}\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */ $8b4ecc405ab6d560$var$Cartesian3.fromSpherical = function(spherical, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"spherical\", spherical);\n    //>>includeEnd('debug');\n    if (!(0, $jQJji.default)(result)) result = new $8b4ecc405ab6d560$var$Cartesian3();\n    const clock = spherical.clock;\n    const cone = spherical.cone;\n    const magnitude = spherical.magnitude ?? 1.0;\n    const radial = magnitude * Math.sin(cone);\n    result.x = radial * Math.cos(clock);\n    result.y = radial * Math.sin(clock);\n    result.z = magnitude * Math.cos(cone);\n    return result;\n};\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */ $8b4ecc405ab6d560$var$Cartesian3.fromElements = function(x, y, z, result) {\n    if (!(0, $jQJji.default)(result)) return new $8b4ecc405ab6d560$var$Cartesian3(x, y, z);\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    return result;\n};\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */ $8b4ecc405ab6d560$var$Cartesian3.clone = function(cartesian, result) {\n    if (!(0, $jQJji.default)(cartesian)) return undefined;\n    if (!(0, $jQJji.default)(result)) return new $8b4ecc405ab6d560$var$Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n    result.x = cartesian.x;\n    result.y = cartesian.y;\n    result.z = cartesian.z;\n    return result;\n};\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */ $8b4ecc405ab6d560$var$Cartesian3.fromCartesian4 = $8b4ecc405ab6d560$var$Cartesian3.clone;\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */ $8b4ecc405ab6d560$var$Cartesian3.packedLength = 3;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */ $8b4ecc405ab6d560$var$Cartesian3.pack = function(value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"value\", value);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    startingIndex = startingIndex ?? 0;\n    array[startingIndex++] = value.x;\n    array[startingIndex++] = value.y;\n    array[startingIndex] = value.z;\n    return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */ $8b4ecc405ab6d560$var$Cartesian3.unpack = function(array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    startingIndex = startingIndex ?? 0;\n    if (!(0, $jQJji.default)(result)) result = new $8b4ecc405ab6d560$var$Cartesian3();\n    result.x = array[startingIndex++];\n    result.y = array[startingIndex++];\n    result.z = array[startingIndex];\n    return result;\n};\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {number[]} The packed array.\n */ $8b4ecc405ab6d560$var$Cartesian3.packArray = function(array, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    //>>includeEnd('debug');\n    const length = array.length;\n    const resultLength = length * 3;\n    if (!(0, $jQJji.default)(result)) result = new Array(resultLength);\n    else if (!Array.isArray(result) && result.length !== resultLength) //>>includeStart('debug', pragmas.debug);\n    throw new (0, $1vHsR.default)(\"If result is a typed array, it must have exactly array.length * 3 elements\");\n    else if (result.length !== resultLength) result.length = resultLength;\n    for(let i = 0; i < length; ++i)$8b4ecc405ab6d560$var$Cartesian3.pack(array[i], result, i * 3);\n    return result;\n};\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */ $8b4ecc405ab6d560$var$Cartesian3.unpackArray = function(array, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"array\", array);\n    (0, $3pzcG.default).typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n    if (array.length % 3 !== 0) throw new (0, $1vHsR.default)(\"array length must be a multiple of 3.\");\n    //>>includeEnd('debug');\n    const length = array.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 3);\n    else result.length = length / 3;\n    for(let i = 0; i < length; i += 3){\n        const index = i / 3;\n        result[index] = $8b4ecc405ab6d560$var$Cartesian3.unpack(array, i, result[index]);\n    }\n    return result;\n};\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromArray = $8b4ecc405ab6d560$var$Cartesian3.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */ $8b4ecc405ab6d560$var$Cartesian3.maximumComponent = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */ $8b4ecc405ab6d560$var$Cartesian3.minimumComponent = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */ $8b4ecc405ab6d560$var$Cartesian3.minimumByComponent = function(first, second, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"first\", first);\n    (0, $3pzcG.default).typeOf.object(\"second\", second);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.min(first.x, second.x);\n    result.y = Math.min(first.y, second.y);\n    result.z = Math.min(first.z, second.z);\n    return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */ $8b4ecc405ab6d560$var$Cartesian3.maximumByComponent = function(first, second, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"first\", first);\n    (0, $3pzcG.default).typeOf.object(\"second\", second);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.max(first.x, second.x);\n    result.y = Math.max(first.y, second.y);\n    result.z = Math.max(first.z, second.z);\n    return result;\n};\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */ $8b4ecc405ab6d560$var$Cartesian3.clamp = function(value, min, max, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"value\", value);\n    (0, $3pzcG.default).typeOf.object(\"min\", min);\n    (0, $3pzcG.default).typeOf.object(\"max\", max);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const x = (0, $AXvpI.default).clamp(value.x, min.x, max.x);\n    const y = (0, $AXvpI.default).clamp(value.y, min.y, max.y);\n    const z = (0, $AXvpI.default).clamp(value.z, min.z, max.z);\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */ $8b4ecc405ab6d560$var$Cartesian3.magnitudeSquared = function(cartesian) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    //>>includeEnd('debug');\n    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */ $8b4ecc405ab6d560$var$Cartesian3.magnitude = function(cartesian) {\n    return Math.sqrt($8b4ecc405ab6d560$var$Cartesian3.magnitudeSquared(cartesian));\n};\nconst $8b4ecc405ab6d560$var$distanceScratch = new $8b4ecc405ab6d560$var$Cartesian3();\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */ $8b4ecc405ab6d560$var$Cartesian3.distance = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $8b4ecc405ab6d560$var$Cartesian3.subtract(left, right, $8b4ecc405ab6d560$var$distanceScratch);\n    return $8b4ecc405ab6d560$var$Cartesian3.magnitude($8b4ecc405ab6d560$var$distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */ $8b4ecc405ab6d560$var$Cartesian3.distanceSquared = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $8b4ecc405ab6d560$var$Cartesian3.subtract(left, right, $8b4ecc405ab6d560$var$distanceScratch);\n    return $8b4ecc405ab6d560$var$Cartesian3.magnitudeSquared($8b4ecc405ab6d560$var$distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.normalize = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const magnitude = $8b4ecc405ab6d560$var$Cartesian3.magnitude(cartesian);\n    result.x = cartesian.x / magnitude;\n    result.y = cartesian.y / magnitude;\n    result.z = cartesian.z / magnitude;\n    //>>includeStart('debug', pragmas.debug);\n    if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) throw new (0, $1vHsR.default)(\"normalized result is not a number\");\n    //>>includeEnd('debug');\n    return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The dot product.\n */ $8b4ecc405ab6d560$var$Cartesian3.dot = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.multiplyComponents = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x * right.x;\n    result.y = left.y * right.y;\n    result.z = left.z * right.z;\n    return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.divideComponents = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x / right.x;\n    result.y = left.y / right.y;\n    result.z = left.z / right.z;\n    return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.add = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x + right.x;\n    result.y = left.y + right.y;\n    result.z = left.z + right.z;\n    return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.subtract = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = left.x - right.x;\n    result.y = left.y - right.y;\n    result.z = left.z - right.z;\n    return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.number(\"scalar\", scalar);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = cartesian.x * scalar;\n    result.y = cartesian.y * scalar;\n    result.z = cartesian.z * scalar;\n    return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.divideByScalar = function(cartesian, scalar, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.number(\"scalar\", scalar);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = cartesian.x / scalar;\n    result.y = cartesian.y / scalar;\n    result.z = cartesian.z / scalar;\n    return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.negate = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = -cartesian.x;\n    result.y = -cartesian.y;\n    result.z = -cartesian.z;\n    return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.abs = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = Math.abs(cartesian.x);\n    result.y = Math.abs(cartesian.y);\n    result.z = Math.abs(cartesian.z);\n    return result;\n};\nconst $8b4ecc405ab6d560$var$lerpScratch = new $8b4ecc405ab6d560$var$Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */ $8b4ecc405ab6d560$var$Cartesian3.lerp = function(start, end, t, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"start\", start);\n    (0, $3pzcG.default).typeOf.object(\"end\", end);\n    (0, $3pzcG.default).typeOf.number(\"t\", t);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    $8b4ecc405ab6d560$var$Cartesian3.multiplyByScalar(end, t, $8b4ecc405ab6d560$var$lerpScratch);\n    result = $8b4ecc405ab6d560$var$Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n    return $8b4ecc405ab6d560$var$Cartesian3.add($8b4ecc405ab6d560$var$lerpScratch, result, result);\n};\nconst $8b4ecc405ab6d560$var$angleBetweenScratch = new $8b4ecc405ab6d560$var$Cartesian3();\nconst $8b4ecc405ab6d560$var$angleBetweenScratch2 = new $8b4ecc405ab6d560$var$Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */ $8b4ecc405ab6d560$var$Cartesian3.angleBetween = function(left, right) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    //>>includeEnd('debug');\n    $8b4ecc405ab6d560$var$Cartesian3.normalize(left, $8b4ecc405ab6d560$var$angleBetweenScratch);\n    $8b4ecc405ab6d560$var$Cartesian3.normalize(right, $8b4ecc405ab6d560$var$angleBetweenScratch2);\n    const cosine = $8b4ecc405ab6d560$var$Cartesian3.dot($8b4ecc405ab6d560$var$angleBetweenScratch, $8b4ecc405ab6d560$var$angleBetweenScratch2);\n    const sine = $8b4ecc405ab6d560$var$Cartesian3.magnitude($8b4ecc405ab6d560$var$Cartesian3.cross($8b4ecc405ab6d560$var$angleBetweenScratch, $8b4ecc405ab6d560$var$angleBetweenScratch2, $8b4ecc405ab6d560$var$angleBetweenScratch));\n    return Math.atan2(sine, cosine);\n};\nconst $8b4ecc405ab6d560$var$mostOrthogonalAxisScratch = new $8b4ecc405ab6d560$var$Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */ $8b4ecc405ab6d560$var$Cartesian3.mostOrthogonalAxis = function(cartesian, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"cartesian\", cartesian);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const f = $8b4ecc405ab6d560$var$Cartesian3.normalize(cartesian, $8b4ecc405ab6d560$var$mostOrthogonalAxisScratch);\n    $8b4ecc405ab6d560$var$Cartesian3.abs(f, f);\n    if (f.x <= f.y) {\n        if (f.x <= f.z) result = $8b4ecc405ab6d560$var$Cartesian3.clone($8b4ecc405ab6d560$var$Cartesian3.UNIT_X, result);\n        else result = $8b4ecc405ab6d560$var$Cartesian3.clone($8b4ecc405ab6d560$var$Cartesian3.UNIT_Z, result);\n    } else if (f.y <= f.z) result = $8b4ecc405ab6d560$var$Cartesian3.clone($8b4ecc405ab6d560$var$Cartesian3.UNIT_Y, result);\n    else result = $8b4ecc405ab6d560$var$Cartesian3.clone($8b4ecc405ab6d560$var$Cartesian3.UNIT_Z, result);\n    return result;\n};\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */ $8b4ecc405ab6d560$var$Cartesian3.projectVector = function(a, b, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"a\", a);\n    (0, $3pzcG.default).defined(\"b\", b);\n    (0, $3pzcG.default).defined(\"result\", result);\n    //>>includeEnd('debug');\n    const scalar = $8b4ecc405ab6d560$var$Cartesian3.dot(a, b) / $8b4ecc405ab6d560$var$Cartesian3.dot(b, b);\n    return $8b4ecc405ab6d560$var$Cartesian3.multiplyByScalar(b, scalar, result);\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */ $8b4ecc405ab6d560$var$Cartesian3.equals = function(left, right) {\n    return left === right || (0, $jQJji.default)(left) && (0, $jQJji.default)(right) && left.x === right.x && left.y === right.y && left.z === right.z;\n};\n/**\n * @private\n */ $8b4ecc405ab6d560$var$Cartesian3.equalsArray = function(cartesian, array, offset) {\n    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */ $8b4ecc405ab6d560$var$Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n    return left === right || (0, $jQJji.default)(left) && (0, $jQJji.default)(right) && (0, $AXvpI.default).equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && (0, $AXvpI.default).equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && (0, $AXvpI.default).equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */ $8b4ecc405ab6d560$var$Cartesian3.cross = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    const leftX = left.x;\n    const leftY = left.y;\n    const leftZ = left.z;\n    const rightX = right.x;\n    const rightY = right.y;\n    const rightZ = right.z;\n    const x = leftY * rightZ - leftZ * rightY;\n    const y = leftZ * rightX - leftX * rightZ;\n    const z = leftX * rightY - leftY * rightX;\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    return result;\n};\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */ $8b4ecc405ab6d560$var$Cartesian3.midpoint = function(left, right, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"left\", left);\n    (0, $3pzcG.default).typeOf.object(\"right\", right);\n    (0, $3pzcG.default).typeOf.object(\"result\", result);\n    //>>includeEnd('debug');\n    result.x = (left.x + right.x) * 0.5;\n    result.y = (left.y + right.y) * 0.5;\n    result.z = (left.z + right.z) * 0.5;\n    return result;\n};\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {number} longitude The longitude, in degrees\n * @param {number} latitude The latitude, in degrees\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.number(\"longitude\", longitude);\n    (0, $3pzcG.default).typeOf.number(\"latitude\", latitude);\n    //>>includeEnd('debug');\n    longitude = (0, $AXvpI.default).toRadians(longitude);\n    latitude = (0, $AXvpI.default).toRadians(latitude);\n    return $8b4ecc405ab6d560$var$Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\nlet $8b4ecc405ab6d560$var$scratchN = new $8b4ecc405ab6d560$var$Cartesian3();\nlet $8b4ecc405ab6d560$var$scratchK = new $8b4ecc405ab6d560$var$Cartesian3();\n// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set\n$8b4ecc405ab6d560$var$Cartesian3._ellipsoidRadiiSquared = new $8b4ecc405ab6d560$var$Cartesian3(40680631590769, 40680631590769, 40408299984661.445);\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {number} longitude The longitude, in radians\n * @param {number} latitude The latitude, in radians\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.number(\"longitude\", longitude);\n    (0, $3pzcG.default).typeOf.number(\"latitude\", latitude);\n    //>>includeEnd('debug');\n    height = height ?? 0.0;\n    const radiiSquared = !(0, $jQJji.default)(ellipsoid) ? $8b4ecc405ab6d560$var$Cartesian3._ellipsoidRadiiSquared : ellipsoid.radiiSquared;\n    const cosLatitude = Math.cos(latitude);\n    $8b4ecc405ab6d560$var$scratchN.x = cosLatitude * Math.cos(longitude);\n    $8b4ecc405ab6d560$var$scratchN.y = cosLatitude * Math.sin(longitude);\n    $8b4ecc405ab6d560$var$scratchN.z = Math.sin(latitude);\n    $8b4ecc405ab6d560$var$scratchN = $8b4ecc405ab6d560$var$Cartesian3.normalize($8b4ecc405ab6d560$var$scratchN, $8b4ecc405ab6d560$var$scratchN);\n    $8b4ecc405ab6d560$var$Cartesian3.multiplyComponents(radiiSquared, $8b4ecc405ab6d560$var$scratchN, $8b4ecc405ab6d560$var$scratchK);\n    const gamma = Math.sqrt($8b4ecc405ab6d560$var$Cartesian3.dot($8b4ecc405ab6d560$var$scratchN, $8b4ecc405ab6d560$var$scratchK));\n    $8b4ecc405ab6d560$var$scratchK = $8b4ecc405ab6d560$var$Cartesian3.divideByScalar($8b4ecc405ab6d560$var$scratchK, gamma, $8b4ecc405ab6d560$var$scratchK);\n    $8b4ecc405ab6d560$var$scratchN = $8b4ecc405ab6d560$var$Cartesian3.multiplyByScalar($8b4ecc405ab6d560$var$scratchN, height, $8b4ecc405ab6d560$var$scratchN);\n    if (!(0, $jQJji.default)(result)) result = new $8b4ecc405ab6d560$var$Cartesian3();\n    return $8b4ecc405ab6d560$var$Cartesian3.add($8b4ecc405ab6d560$var$scratchK, $8b4ecc405ab6d560$var$scratchN, result);\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"coordinates\", coordinates);\n    if (coordinates.length < 2 || coordinates.length % 2 !== 0) throw new (0, $1vHsR.default)(\"the number of coordinates must be a multiple of 2 and at least 2\");\n    //>>includeEnd('debug');\n    const length = coordinates.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 2);\n    else result.length = length / 2;\n    for(let i = 0; i < length; i += 2){\n        const longitude = coordinates[i];\n        const latitude = coordinates[i + 1];\n        const index = i / 2;\n        result[index] = $8b4ecc405ab6d560$var$Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);\n    }\n    return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"coordinates\", coordinates);\n    if (coordinates.length < 2 || coordinates.length % 2 !== 0) throw new (0, $1vHsR.default)(\"the number of coordinates must be a multiple of 2 and at least 2\");\n    //>>includeEnd('debug');\n    const length = coordinates.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 2);\n    else result.length = length / 2;\n    for(let i = 0; i < length; i += 2){\n        const longitude = coordinates[i];\n        const latitude = coordinates[i + 1];\n        const index = i / 2;\n        result[index] = $8b4ecc405ab6d560$var$Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);\n    }\n    return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"coordinates\", coordinates);\n    if (coordinates.length < 3 || coordinates.length % 3 !== 0) throw new (0, $1vHsR.default)(\"the number of coordinates must be a multiple of 3 and at least 3\");\n    //>>includeEnd('debug');\n    const length = coordinates.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 3);\n    else result.length = length / 3;\n    for(let i = 0; i < length; i += 3){\n        const longitude = coordinates[i];\n        const latitude = coordinates[i + 1];\n        const height = coordinates[i + 2];\n        const index = i / 3;\n        result[index] = $8b4ecc405ab6d560$var$Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);\n    }\n    return result;\n};\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */ $8b4ecc405ab6d560$var$Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).defined(\"coordinates\", coordinates);\n    if (coordinates.length < 3 || coordinates.length % 3 !== 0) throw new (0, $1vHsR.default)(\"the number of coordinates must be a multiple of 3 and at least 3\");\n    //>>includeEnd('debug');\n    const length = coordinates.length;\n    if (!(0, $jQJji.default)(result)) result = new Array(length / 3);\n    else result.length = length / 3;\n    for(let i = 0; i < length; i += 3){\n        const longitude = coordinates[i];\n        const latitude = coordinates[i + 1];\n        const height = coordinates[i + 2];\n        const index = i / 3;\n        result[index] = $8b4ecc405ab6d560$var$Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);\n    }\n    return result;\n};\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */ $8b4ecc405ab6d560$var$Cartesian3.ZERO = Object.freeze(new $8b4ecc405ab6d560$var$Cartesian3(0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */ $8b4ecc405ab6d560$var$Cartesian3.ONE = Object.freeze(new $8b4ecc405ab6d560$var$Cartesian3(1.0, 1.0, 1.0));\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */ $8b4ecc405ab6d560$var$Cartesian3.UNIT_X = Object.freeze(new $8b4ecc405ab6d560$var$Cartesian3(1.0, 0.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */ $8b4ecc405ab6d560$var$Cartesian3.UNIT_Y = Object.freeze(new $8b4ecc405ab6d560$var$Cartesian3(0.0, 1.0, 0.0));\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */ $8b4ecc405ab6d560$var$Cartesian3.UNIT_Z = Object.freeze(new $8b4ecc405ab6d560$var$Cartesian3(0.0, 0.0, 1.0));\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */ $8b4ecc405ab6d560$var$Cartesian3.prototype.clone = function(result) {\n    return $8b4ecc405ab6d560$var$Cartesian3.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */ $8b4ecc405ab6d560$var$Cartesian3.prototype.equals = function(right) {\n    return $8b4ecc405ab6d560$var$Cartesian3.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */ $8b4ecc405ab6d560$var$Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\n    return $8b4ecc405ab6d560$var$Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.\n */ $8b4ecc405ab6d560$var$Cartesian3.prototype.toString = function() {\n    return `(${this.x}, ${this.y}, ${this.z})`;\n};\nvar $8b4ecc405ab6d560$export$2e2bcd8739ae039 = $8b4ecc405ab6d560$var$Cartesian3;\n\n});\n\nparcelRegister(\"9btZb\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $6afc66b303be9bae$export$2e2bcd8739ae039);\n\nvar $bXwZF = parcelRequire(\"bXwZF\");\n\nvar $3pzcG = parcelRequire(\"3pzcG\");\n\nvar $jQJji = parcelRequire(\"jQJji\");\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */ function $6afc66b303be9bae$var$Ray(origin, direction) {\n    direction = (0, $bXwZF.default).clone(direction ?? (0, $bXwZF.default).ZERO);\n    if (!(0, $bXwZF.default).equals(direction, (0, $bXwZF.default).ZERO)) (0, $bXwZF.default).normalize(direction, direction);\n    /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */ this.origin = (0, $bXwZF.default).clone(origin ?? (0, $bXwZF.default).ZERO);\n    /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */ this.direction = direction;\n}\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */ $6afc66b303be9bae$var$Ray.clone = function(ray, result) {\n    if (!(0, $jQJji.default)(ray)) return undefined;\n    if (!(0, $jQJji.default)(result)) return new $6afc66b303be9bae$var$Ray(ray.origin, ray.direction);\n    result.origin = (0, $bXwZF.default).clone(ray.origin);\n    result.direction = (0, $bXwZF.default).clone(ray.direction);\n    return result;\n};\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */ $6afc66b303be9bae$var$Ray.getPoint = function(ray, t, result) {\n    //>>includeStart('debug', pragmas.debug);\n    (0, $3pzcG.default).typeOf.object(\"ray\", ray);\n    (0, $3pzcG.default).typeOf.number(\"t\", t);\n    //>>includeEnd('debug');\n    if (!(0, $jQJji.default)(result)) result = new (0, $bXwZF.default)();\n    result = (0, $bXwZF.default).multiplyByScalar(ray.direction, t, result);\n    return (0, $bXwZF.default).add(ray.origin, result, result);\n};\nvar $6afc66b303be9bae$export$2e2bcd8739ae039 = $6afc66b303be9bae$var$Ray;\n\n});\n\n\n//# sourceMappingURL=cesium-compass.14794d0a.js.map\n","import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {number[]} The packed array.\n */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */\nCartesian2.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n\n  result.x = x;\n  result.y = y;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nconst lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian2();\nconst angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2),\n  );\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return `(${this.x}, ${this.y})`;\n};\nexport default Cartesian2;\n","import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const clock = spherical.clock;\n  const cone = spherical.cone;\n  const magnitude = spherical.magnitude ?? 1.0;\n  const radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */\nCartesian3.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nconst lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian3();\nconst angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  const sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch,\n    ),\n  );\n  return Math.atan2(sine, cosine);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n\n  const x = leftY * rightZ - leftZ * rightY;\n  const y = leftZ * rightX - leftX * rightZ;\n  const z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {number} longitude The longitude, in degrees\n * @param {number} latitude The latitude, in degrees\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nlet scratchN = new Cartesian3();\nlet scratchK = new Cartesian3();\n\n// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set\nCartesian3._ellipsoidRadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793,\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {number} longitude The longitude, in radians\n * @param {number} latitude The latitude, in radians\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = height ?? 0.0;\n\n  const radiiSquared = !defined(ellipsoid)\n    ? Cartesian3._ellipsoidRadiiSquared\n    : ellipsoid.radiiSquared;\n\n  const cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z})`;\n};\nexport default Cartesian3;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(direction ?? Cartesian3.ZERO);\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(origin ?? Cartesian3.ZERO);\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$f401ccd6337211aa$export$2e2bcd8739ae039","$3pzcG","$jQJji","$1vHsR","$AXvpI","$f401ccd6337211aa$var$Cartesian2","x","y","fromElements","result","default","clone","cartesian","fromCartesian3","fromCartesian4","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","magnitude","sqrt","$f401ccd6337211aa$var$distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","cross","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","$f401ccd6337211aa$var$lerpScratch","lerp","start","end","t","$f401ccd6337211aa$var$angleBetweenScratch","$f401ccd6337211aa$var$angleBetweenScratch2","angleBetween","acosClamped","$f401ccd6337211aa$var$mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","freeze","ONE","prototype","toString","$8b4ecc405ab6d560$export$2e2bcd8739ae039","$8b4ecc405ab6d560$var$Cartesian3","z","fromSpherical","spherical","clock","cone","radial","sin","cos","$8b4ecc405ab6d560$var$distanceScratch","$8b4ecc405ab6d560$var$lerpScratch","$8b4ecc405ab6d560$var$angleBetweenScratch","$8b4ecc405ab6d560$var$angleBetweenScratch2","cosine","atan2","$8b4ecc405ab6d560$var$mostOrthogonalAxisScratch","UNIT_Z","projectVector","a","b","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","$8b4ecc405ab6d560$var$scratchN","$8b4ecc405ab6d560$var$scratchK","_ellipsoidRadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","$6afc66b303be9bae$export$2e2bcd8739ae039","$bXwZF","$6afc66b303be9bae$var$Ray","origin","direction","ray","getPoint"],"version":3,"file":"cesium-compass.14794d0a.js.map"}